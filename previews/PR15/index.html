<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · Lighthouse</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="Lighthouse logo"/></a><div class="docs-package-name"><span class="docs-autofit">Lighthouse</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#The-AbstractClassifier-Interface"><span>The <code>AbstractClassifier</code> Interface</span></a></li><li><a class="tocitem" href="#The-learn!-Interface"><span>The <code>learn!</code> Interface</span></a></li><li><a class="tocitem" href="#Performance-Metrics"><span>Performance Metrics</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="terminology/">Terminology</a></li><li><a class="tocitem" href="evaluation_metrics/">Evaluation metrics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="The-AbstractClassifier-Interface"><a class="docs-heading-anchor" href="#The-AbstractClassifier-Interface">The <code>AbstractClassifier</code> Interface</a><a id="The-AbstractClassifier-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractClassifier-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.AbstractClassifier" href="#Lighthouse.AbstractClassifier"><code>Lighthouse.AbstractClassifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractClassifier</code></pre><p>An abstract type whose subtypes <code>C&lt;:AbstractClassifier</code> must implement:</p><ul><li><a href="#Lighthouse.classes"><code>Lighthouse.classes</code></a></li><li><a href="#Lighthouse.train!"><code>Lighthouse.train!</code></a></li><li><a href="#Lighthouse.loss_and_prediction"><code>Lighthouse.loss_and_prediction</code></a></li></ul><p>Subtypes may additionally overload default implementations for:</p><ul><li><a href="#Lighthouse.onehot"><code>Lighthouse.onehot</code></a></li><li><a href="#Lighthouse.onecold"><code>Lighthouse.onecold</code></a></li><li><a href="#Lighthouse.is_early_stopping_exception"><code>Lighthouse.is_early_stopping_exception</code></a></li></ul><p>The <code>AbstractClassifier</code> interface is built upon the expectation that any multiclass label will be represented in one of two standardized forms:</p><ul><li>&quot;soft label&quot;: a probability distribution vector where the <code>i</code>th element is the probability assigned to the <code>i</code>th class in <code>classes(classifier)</code>.</li><li>&quot;hard label&quot;: the interger index of a corresponding class in <code>classes(classifier)</code>.</li></ul><p>Internally, Lighthouse converts hard labels to soft labels via <code>onehot</code> and soft labels to hard labels via <code>onecold</code>.</p><p>See also: <a href="#Lighthouse.learn!"><code>learn!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/classifier.jl#L7-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.classes" href="#Lighthouse.classes"><code>Lighthouse.classes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.classes(classifier::AbstractClassifier)</code></pre><p>Return a <code>Vector</code> or <code>Tuple</code> of class values for <code>classifier</code>.</p><p>This method must be implemented for each <code>AbstractClassifier</code> subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/classifier.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.train!" href="#Lighthouse.train!"><code>Lighthouse.train!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.train!(classifier::AbstractClassifier, batches, logger::LearnLogger)</code></pre><p>Train <code>classifier</code> on the iterable <code>batches</code> for a single epoch. This function is called once per epoch by <a href="#Lighthouse.learn!"><code>learn!</code></a>.</p><p>This method must be implemented for each <code>AbstractClassifier</code> subtype. Implementers should ensure that the training loss is properly logged to <code>logger</code> by calling <code>Lighthouse.log_value!(logger, &quot;train/loss_per_batch&quot;, batch_loss)</code> for each batch in <code>batches</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/classifier.jl#L45-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.loss_and_prediction" href="#Lighthouse.loss_and_prediction"><code>Lighthouse.loss_and_prediction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.loss_and_prediction(classifier::AbstractClassifier,
                               input_batch::AbstractArray,
                               args...)</code></pre><p>Return <code>(loss, soft_label_batch)</code> given <code>input_batch</code> and any additional <code>args</code> provided by the caller; <code>loss</code> is a scalar, which <code>soft_label_batch</code> is a matrix with <code>length(classes(classifier))</code> rows and <code>size(input_batch)</code>.</p><p>Specifically, the <code>i</code>th column of <code>soft_label_batch</code> is <code>classifier</code>&#39;s soft label prediction for the <code>i</code>th sample in <code>input_batch</code>.</p><p>This method must be implemented for each <code>AbstractClassifier</code> subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/classifier.jl#L58-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.onehot" href="#Lighthouse.onehot"><code>Lighthouse.onehot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.onehot(classifier::AbstractClassifier, hard_label)</code></pre><p>Return the one-hot encoded probability distribution vector corresponding to the given <code>hard_label</code>. <code>hard_label</code> must be an integer index in the range <code>1:length(classes(classifier))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/classifier.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.onecold" href="#Lighthouse.onecold"><code>Lighthouse.onecold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.onecold(classifier::AbstractClassifier, soft_label)</code></pre><p>Return the hard label (integer index in the range <code>1:length(classes(classifier))</code>) corresponding to the given <code>soft_label</code> (one-hot encoded probability distribution vector).</p><p>By default, this function returns <code>argmax(soft_label)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/classifier.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.is_early_stopping_exception" href="#Lighthouse.is_early_stopping_exception"><code>Lighthouse.is_early_stopping_exception</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.is_early_stopping_exception(classifier::AbstractClassifier, exception)</code></pre><p>Return <code>true</code> if <code>exception</code> should be considered an &quot;early-stopping exception&quot; (e.g. <code>Flux.Optimise.StopException</code>), rather than rethrown from <a href="#Lighthouse.learn!"><code>learn!</code></a>.</p><p>This function returns <code>false</code> by default, but can be overloaded by subtypes of <code>AbstractClassifier</code> that employ exceptions as early-stopping mechanisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/classifier.jl#L97-L105">source</a></section></article><h2 id="The-learn!-Interface"><a class="docs-heading-anchor" href="#The-learn!-Interface">The <code>learn!</code> Interface</a><a id="The-learn!-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-learn!-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.LearnLogger" href="#Lighthouse.LearnLogger"><code>Lighthouse.LearnLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LearnLogger</code></pre><p>A struct that wraps a <code>TensorBoardLogger.TBLogger</code> in order to enforce the following:</p><ul><li>all values logged to Tensorboard should be accessible to the <code>post_epoch_callback</code> argument to <a href="#Lighthouse.learn!"><code>learn!</code></a></li><li>all values that are cached during <a href="#Lighthouse.learn!"><code>learn!</code></a> should be logged to Tensorboard</li></ul><p>To access values logged to a <code>LearnLogger</code> instance, inspect the instance&#39;s <code>logged</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.learn!" href="#Lighthouse.learn!"><code>Lighthouse.learn!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">learn!(model::AbstractClassifier, logger,
       get_train_batches, get_test_batches, votes,
       elected=majority.(eachrow(votes), (1:length(classes(model)),));
       epoch_limit=100, post_epoch_callback=(current_epoch -&gt; nothing),
       optimal_threshold_class::Union{Nothing,Integer}=nothing)</code></pre><p>Return <code>model</code> after optimizing its parameters across multiple epochs of training and test, logging Lighthouse&#39;s standardized suite of classifier performance metrics to <code>logger</code> throughout the optimization process.</p><p>The following phases are executed at each epoch (note: in the below lists of logged values, <code>$resource</code> takes the values of the field names of <code>Lighthouse.ResourceInfo</code>):</p><ol><li><p>Train <code>model</code> by calling <code>train!(model, get_train_batches(), logger)</code>. The following quantities are logged to <code>logger</code> during this phase:</p><ul><li><code>train/loss_per_batch</code></li><li>any additional quantities logged by the relevant model/framework-specific implementation of <code>train!</code>.</li></ul></li><li><p>Compute <code>model</code>&#39;s predictions on test set provided by <code>get_test_batches()</code> (see below for details). The following quantities are logged to <code>logger</code> during this phase:</p><ul><li><code>test_set_prediction/loss_per_batch</code></li><li><code>test_set_prediction/mean_loss_per_epoch</code></li><li><code>test_set_prediction/$resource_per_batch</code></li></ul></li><li><p>Compute a battery of metrics to evaluate <code>model</code>&#39;s performance on the test set based on the test set prediction phase. The following quantities are logged to <code>logger</code> during this phase:</p><ul><li><code>test_set_evaluation/metrics_per_epoch</code></li><li><code>test_set_evaluation/$resource_per_epoch</code></li></ul></li><li><p>Call <code>post_epoch_callback(current_epoch)</code>.</p></li></ol><p>Where...</p><ul><li><p><code>get_train_batches</code> is a zero-argument function that returns an iterable of   training set batches. Internally, <code>learn!</code> uses this function when it calls   <code>train!(model, get_train_batches(), logger)</code>.</p></li><li><p><code>get_test_batches</code> is a zero-argument function that returns an iterable   of test set batches used during the current epoch&#39;s test phase. Each element of   the iterable takes the form <code>(batch, votes_locations)</code>. Internally, <code>batch</code> is   passed to <a href="#Lighthouse.loss_and_prediction"><code>loss_and_prediction</code></a> as <code>loss_and_prediction(model, batch...)</code>,   and <code>votes_locations[i]</code> is expected to yield the row index of <code>votes</code> that   corresponds to the <code>i</code>th sample in <code>batch</code>.</p></li><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose   rows correspond to the samples in the test set that have been voted on. If   <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will   simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>elected</code> is a vector of hard labels where the <code>i</code>th element is the hard label   elected as &quot;ground truth&quot; out of <code>votes[i, :]</code>.</p></li><li><p><code>optimal_threshold_class</code> is the class index (<code>1</code> or <code>2</code>) for which to calculate   an optimal threshold for converting <code>predicted_soft_labels</code> to <code>predicted_hard_labels</code>.   This is only a valid parameter when <code>length(classes) == 2</code>. If <code>optimal_threshold_class</code>   is present, test set evaluation will be based on predicted hard labels calculated   with this threshold; if <code>optimal_threshold_class</code> is <code>nothing</code>, predicted hard labels   will be calculated via <code>onecold(classifier, soft_label)</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L843-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.upon" href="#Lighthouse.upon"><code>Lighthouse.upon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upon(logged::Dict{String,Any}, field::AbstractString; condition, initial)</code></pre><p>Return a closure that can be called to check the most recent state of <code>logger.logged[field]</code> and trigger a caller-provided function when <code>condition(recent_state, previously_chosen_state)</code> is <code>true</code>.</p><p>For example:</p><pre><code class="language-none">upon_loss_decrease = upon(logger, &quot;test_set_prediction/mean_loss_per_epoch&quot;;
                          condition=&lt;, initial=Inf)

save_upon_loss_decrease = _ -&gt; begin
    upon_loss_decrease(new_lowest_loss -&gt; save_my_model(model, new_lowest_loss),
                       consecutive_failures -&gt; consecutive_failures &gt; 10 &amp;&amp; Flux.stop())
end

learn!(model, logger, get_train_batches, get_test_batches, votes;
       post_epoch_callback=save_upon_loss_decrease)</code></pre><p>Specifically, the form of the returned closure is <code>f(on_true, on_false)</code> where <code>on_true(state)</code> is called if <code>condition(state, previously_chosen_state)</code> is <code>true</code>. Otherwise, <code>on_false(consecutive_falses)</code> is called where <code>consecutive_falses</code> is the number of <code>condition</code> calls that have returned <code>false</code> since the last <code>condition</code> call returned <code>true</code>.</p><p>Note that the returned closure is a no-op if <code>logger.logged[field]</code> has not been updated since the most recent call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L954-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.evaluate!" href="#Lighthouse.evaluate!"><code>Lighthouse.evaluate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate!(predicted_hard_labels::AbstractVector,
          predicted_soft_labels::AbstractMatrix,
          elected_hard_labels::AbstractVector,
          classes, logger::LearnLogger;
          logger_prefix, logger_suffix,
          votes::Union{Nothing,AbstractMatrix}=nothing,
          thresholds=0.0:0.01:1.0,
          optimal_threshold_class::Union{Nothing,Integer}=nothing)</code></pre><p>Return <code>nothing</code> after computing and logging a battery of classifier performance metrics that each compare <code>predicted_soft_labels</code> and/or <code>predicted_hard_labels</code> agaist <code>elected_hard_labels</code>.</p><p>The following quantities are logged to <code>logger</code>:     - <code>&lt;logger_prefix&gt;/metrics&lt;logger_suffix&gt;</code>     - <code>&lt;logger_prefix&gt;/$resource&lt;logger_suffix&gt;</code></p><p>Where...</p><ul><li><p><code>predicted_soft_labels</code> is a matrix of soft labels whose columns correspond to   classes and whose rows correspond to samples in the evaluation set.</p></li><li><p><code>predicted_hard_labels</code> is a vector of hard labels where the <code>i</code>th element   is the hard label predicted by the model for sample <code>i</code> in the evaulation set.</p></li><li><p><code>elected_hard_labels</code> is a vector of hard labels where the <code>i</code>th element   is the hard label elected as &quot;ground truth&quot; for sample <code>i</code> in the evaulation set.</p></li><li><p><code>thresholds</code> are the range of thresholds used by metrics (e.g. PR curves) that   are calculated on the <code>predicted_soft_labels</code> for a range of thresholds.</p></li><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose   rows correspond to the samples in the test set that have been voted on. If   <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will   simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>optimal_threshold_class</code> is the class index (<code>1</code> or <code>2</code>) for which to calculate   an optimal threshold for converting the <code>predicted_soft_labels</code> to   <code>predicted_hard_labels</code>. If present, the input <code>predicted_hard_labels</code> will be   ignored and new <code>predicted_hard_labels</code> will be recalculated from the new threshold.   This is only a valid parameter when <code>length(classes) == 2</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L165-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.predict!" href="#Lighthouse.predict!"><code>Lighthouse.predict!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predict!(model::AbstractClassifier,
         predicted_soft_labels::AbstractMatrix,
         batches, logger::LearnLogger;
         logger_prefix::AbstractString)</code></pre><p>Return <code>mean_loss</code> of all <code>batches</code> after using <code>model</code> to predict their soft labels and storing those results in <code>predicted_soft_labels</code>.</p><p>The following quantities are logged to <code>logger</code>:</p><ul><li><code>&lt;logger_prefix&gt;/loss_per_batch</code></li><li><code>&lt;logger_prefix&gt;/mean_loss_per_epoch</code></li><li><code>&lt;logger_prefix&gt;/$resource_per_batch</code></li></ul><p>Where...</p><ul><li><p><code>model</code> is a model that outputs soft labels when called on a batch of <code>batches</code>, <code>model(batch)</code>.</p></li><li><p><code>predicted_soft_labels</code> is a matrix whose columns correspond to classes and   whose rows correspond to samples in batches, and which is filled in with soft-label predictions.</p></li><li><p><code>batches</code> is an iterable of batches, where each element of   the iterable takes the form <code>(batch, votes_locations)</code>. Internally, <code>batch</code> is   passed to <a href="#Lighthouse.loss_and_prediction"><code>loss_and_prediction</code></a> as <code>loss_and_prediction(model, batch...)</code>.</p></li></ul><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L116-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.forward_logs" href="#Lighthouse.forward_logs"><code>Lighthouse.forward_logs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">forwarding_task = forward_logs(channel, logger::LearnLogger)</code></pre><p>Forwards logs with values supported by <code>TensorBoardLogger</code> to <code>logger::LearnLogger</code>:</p><ul><li>string events of type <code>AbstractString</code></li><li>scalars of type <code>Union{Real,Complex}</code></li><li>plots that <code>TensorBoardLogger</code> can convert to raster images</li></ul><p>returns the <code>forwarding_task:::Task</code> that does the forwarding. To cleanly stop forwarding, <code>close(channel)</code> and <code>wait(forwarding_task)</code>.</p><p>outbox is a Channel or RemoteChannel of Pair{String, Any} field names starting with &quot;<strong>plot</strong>&quot; forward to TensorBoardLogger.log_image</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L75-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._calculate_ea_kappas" href="#Lighthouse._calculate_ea_kappas"><code>Lighthouse._calculate_ea_kappas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_calculate_ea_kappas(predicted_hard_labels, elected_hard_labels, classes)</code></pre><p>Return <code>NamedTuple</code> with keys <code>:per_class</code>, <code>:multiclass</code> containing the Cohen&#39;s Kappa per-class and over all classes, respectively. The value of output key <code>:per_class</code> is an <code>Array</code> such that item <code>i</code> is the Cohen&#39;s kappa calculated for class <code>i</code>.</p><p>Where...</p><ul><li><code>predicted_hard_labels</code> is a vector of hard labels where the <code>i</code>th element   is the hard label predicted by the model for sample <code>i</code> in the evaulation set.</li><li><code>elected_hard_labels</code> is a vector of hard labels where the <code>i</code>th element</li></ul><p>is the hard label elected as &quot;ground truth&quot; for sample <code>i</code> in the evaulation set.</p><ul><li><code>class_count</code> is the number of possible classes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L453-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._calculate_ira_kappas" href="#Lighthouse._calculate_ira_kappas"><code>Lighthouse._calculate_ira_kappas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_calculate_ira_kappas(votes, classes)</code></pre><p>Return <code>NamedTuple</code> with keys <code>:per_class</code>, <code>:multiclass</code> containing the Cohen&#39;s Kappa for inter-rater agreement (IRA) per-class and over all classes, respectively. The value of output key <code>:per_class</code> is an <code>Array</code> such that item <code>i</code> is the IRA kappa calculated for class <code>i</code>.</p><p>Where...</p><ul><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose   rows correspond to the samples in the test set that have been voted on. If   <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will   simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>classes</code> all possible classes voted on.</p></li></ul><p>Returns <code>nothing</code> if <code>votes</code> has only a single voter (i.e., a single column) or if no two voters rated the same sample. Note that vote entries of <code>0</code> are taken to mean that the voter did not rate that sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L483-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._calculate_spearman_correlation" href="#Lighthouse._calculate_spearman_correlation"><code>Lighthouse._calculate_spearman_correlation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_calculate_spearman_correlation(predicted_soft_labels, votes, classes)</code></pre><p>Return <code>NamedTuple</code> with keys <code>:ρ</code>, <code>:n</code>, <code>:ci_lower</code>, and <code>ci_upper</code> that are the Spearman correlation constant ρ and its 95% confidence interval bounds. Only valid for binary classification problems (i.e., <code>length(classes) == 2</code>)</p><p>Where...</p><ul><li><code>predicted_soft_labels</code> is a matrix of soft labels whose columns correspond to   the two classes and whose rows correspond to the samples in the test set that have been   classified. For a given sample, the two class column values must sum to 1 (i.e.,   softmax has been applied to the classification output).</li><li><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose   rows correspond to the samples in the test set that have been voted on. If</li></ul><p><code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will     simply be considered to have not assigned a hard label to <code>sample</code>. May contain     a single voter (i.e., a single column).</p><ul><li><code>classes</code> are the two classes voted on.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L551-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.evaluation_metrics_plot" href="#Lighthouse.evaluation_metrics_plot"><code>Lighthouse.evaluation_metrics_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluation_metrics_plot(predicted_hard_labels::AbstractVector,
                        predicted_soft_labels::AbstractMatrix,
                        elected_hard_labels::AbstractVector,
                        classes,
                        thresholds=0.0:0.01:1.0;
                        votes::Union{Nothing,AbstractMatrix}=nothing,
                        strata::Union{Nothing,AbstractVector{Set{T}} where T}=nothing,
                        optimal_threshold_class::Union{Nothing,Integer}=nothing)</code></pre><p>Return a plot and dictionary containing a battery of classifier performance metrics that each compare <code>predicted_soft_labels</code> and/or <code>predicted_hard_labels</code> agaist <code>elected_hard_labels</code>.</p><p>Where...</p><ul><li><code>predicted_soft_labels</code> is a matrix of soft labels whose columns correspond to</li></ul><p>classes and whose rows correspond to samples in the evaluation set.</p><ul><li><code>predicted_hard_labels</code> is a vector of hard labels where the <code>i</code>th element</li></ul><p>is the hard label predicted by the model for sample <code>i</code> in the evaulation set.</p><ul><li><code>elected_hard_labels</code> is a vector of hard labels where the <code>i</code>th element</li></ul><p>is the hard label elected as &quot;ground truth&quot; for sample <code>i</code> in the evaulation set.</p><ul><li><code>thresholds</code> are the range of thresholds used by metrics (e.g. PR curves) that</li></ul><p>are calculated on the <code>predicted_soft_labels</code> for a range of thresholds.</p><ul><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose   rows correspond to the samples in the test set that have been voted on. If   <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will   simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>strata</code> is a vector of sets of (arbitrarily typed) groups/strata for each sample   in the evaluation set, or <code>nothing</code>. If not <code>nothing</code>, per-class and multiclass   kappas will also be calculated per group/stratum.</p></li><li><p><code>optimal_threshold_class</code> is the class index (<code>1</code> or <code>2</code>) for which to calculate   an optimal threshold for converting the <code>predicted_soft_labels</code> to   <code>predicted_hard_labels</code>. If present, the input <code>predicted_hard_labels</code> will be   ignored and new <code>predicted_hard_labels</code> will be recalculated from the new threshold.   This is only a valid parameter when <code>length(classes) == 2</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/learn.jl#L656-L698">source</a></section></article><h2 id="Performance-Metrics"><a class="docs-heading-anchor" href="#Performance-Metrics">Performance Metrics</a><a id="Performance-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Metrics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.confusion_matrix" href="#Lighthouse.confusion_matrix"><code>Lighthouse.confusion_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">confusion_matrix(class_count::Integer, hard_label_pairs = ())</code></pre><p>Given the iterable <code>hard_label_pairs</code> whose <code>k</code>th element takes the form <code>(first_classifiers_label_for_sample_k, second_classifiers_label_for_sample_k)</code>, return the corresponding confusion matrix where <code>matrix[i, j]</code> is the number of samples that the first classifier labeled <code>i</code> and the second classifier labeled <code>j</code>.</p><p>Note that the returned confusion matrix can be updated in-place with new labels via <code>Lighthouse.increment_at!(matrix, more_hard_label_pairs)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/metrics.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.accuracy" href="#Lighthouse.accuracy"><code>Lighthouse.accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accuracy(confusion::AbstractMatrix)</code></pre><p>Returns the percentage of matching classifications out of total classifications, or <code>missing</code> if <code>all(iszero, confusion)</code>.</p><p>Note that <code>accuracy(confusion)</code> is equivalent to overall percent agreement between <code>confusion</code>&#39;s row classifier and column classifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/metrics.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.binary_statistics" href="#Lighthouse.binary_statistics"><code>Lighthouse.binary_statistics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">binary_statistics(confusion::AbstractMatrix, class_index)</code></pre><p>Treating the rows of <code>confusion</code> as corresponding to predicted classifications and the columns as corresponding to true classifications, return a <code>NamedTuple</code> with the following fields for the given <code>class_index</code>:</p><ul><li><code>predicted_positives</code></li><li><code>predicted_negatives</code></li><li><code>actual_positives</code></li><li><code>actual_negatives</code></li><li><code>true_positives</code></li><li><code>true_negatives</code></li><li><code>false_positives</code></li><li><code>false_negatives</code></li><li><code>true_positive_rate</code></li><li><code>true_negative_rate</code></li><li><code>false_positive_rate</code></li><li><code>false_negative_rate</code></li><li><code>precision</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/metrics.jl#L38-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.cohens_kappa" href="#Lighthouse.cohens_kappa"><code>Lighthouse.cohens_kappa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cohens_kappa(class_count, hard_label_pairs)</code></pre><p>Return <code>(κ, p₀)</code> where <code>κ</code> is Cohen&#39;s kappa and <code>p₀</code> percent agreement given <code>class_count</code> and <code>hard_label_pairs</code> (these arguments take the same form as their equivalents in <a href="#Lighthouse.confusion_matrix"><code>confusion_matrix</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/metrics.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.calibration_curve" href="#Lighthouse.calibration_curve"><code>Lighthouse.calibration_curve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calibration_curve(probabilities, bitmask; bin_count=10)</code></pre><p>Given <code>probabilities</code> (the predicted probabilities of the positive class) and <code>bitmask</code> (a vector of <code>Bool</code>s indicating whether or not the element actually belonged to the positive class), return <code>(bins, fractions, totals, mean_squared_error)</code> where:</p><ul><li><code>bins</code> a vector with <code>bin_count</code> <code>Pairs</code> specifying the calibration curve&#39;s probability bins</li><li><code>fractions</code>: a vector where <code>fractions[i]</code> is the number of values in <code>probabilities</code> that falls within <code>bin[i]</code> over the total number of values within <code>bin[i]</code>, or <code>missing</code> if the total number of values in <code>bin[i]</code> is zero.</li><li><code>totals</code>: a vector where <code>totals[i]</code> the total number of values within <code>bin[i]</code>.</li><li><code>mean_squared_error</code>: The mean squared error of <code>fractions</code> vs. an ideal calibration curve.</li></ul><p>This method is similar to the corresponding scikit-learn method:</p><p>https://scikit-learn.org/stable/modules/generated/sklearn.calibration.calibration_curve.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/metrics.jl#L135-L153">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.majority" href="#Lighthouse.majority"><code>Lighthouse.majority</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">majority([rng::AbstractRNG=Random.GLOBAL_RNG], hard_labels, among::UnitRange)</code></pre><p>Return the majority label within <code>among</code> out of <code>hard_labels</code>:</p><pre><code class="language-none">julia&gt; majority([1, 2, 1, 3, 2, 2, 3], 1:3)
2

julia&gt; majority([1, 2, 1, 3, 2, 2, 3, 4], 3:4)
3</code></pre><p>In the event of a tie, a winner is randomly selected from the tied labels via <code>rng</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/utilities.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.area_under_curve" href="#Lighthouse.area_under_curve"><code>Lighthouse.area_under_curve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">area_under_curve(x, y)</code></pre><p>Calculates the area under the curve specified by the <code>x</code> vector and <code>y</code> vector using the trapezoidal rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/utilities.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.area_under_curve_unit_square" href="#Lighthouse.area_under_curve_unit_square"><code>Lighthouse.area_under_curve_unit_square</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">area_under_curve_unit_square(x, y)</code></pre><p>Calculates the area under the curve specified by the <code>x</code> vector and <code>y</code> vector for a unit square, using the trapezoidal rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/d003f1f307fcdc5934701f968879e63ce03ed213/src/utilities.jl#L32-L37">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="terminology/">Terminology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 December 2020 20:11">Wednesday 16 December 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
