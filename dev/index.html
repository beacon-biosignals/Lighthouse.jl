<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation ¬∑ Lighthouse</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="Lighthouse logo"/></a><div class="docs-package-name"><span class="docs-autofit">Lighthouse</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#The-AbstractClassifier-Interface"><span>The <code>AbstractClassifier</code> Interface</span></a></li><li><a class="tocitem" href="#The-learn!-Interface"><span>The <code>learn!</code> Interface</span></a></li><li><a class="tocitem" href="#The-logging-interface"><span>The logging interface</span></a></li><li><a class="tocitem" href="#Performance-Metrics"><span>Performance Metrics</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="plotting/">Plotting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="The-AbstractClassifier-Interface"><a class="docs-heading-anchor" href="#The-AbstractClassifier-Interface">The <code>AbstractClassifier</code> Interface</a><a id="The-AbstractClassifier-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractClassifier-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.AbstractClassifier" href="#Lighthouse.AbstractClassifier"><code>Lighthouse.AbstractClassifier</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractClassifier</code></pre><p>An abstract type whose subtypes <code>C&lt;:AbstractClassifier</code> must implement:</p><ul><li><a href="#Lighthouse.classes"><code>Lighthouse.classes</code></a></li><li><a href="#Lighthouse.train!"><code>Lighthouse.train!</code></a></li><li><a href="#Lighthouse.loss_and_prediction"><code>Lighthouse.loss_and_prediction</code></a></li></ul><p>Subtypes may additionally overload default implementations for:</p><ul><li><a href="#Lighthouse.onehot"><code>Lighthouse.onehot</code></a></li><li><a href="#Lighthouse.onecold"><code>Lighthouse.onecold</code></a></li><li><a href="#Lighthouse.is_early_stopping_exception"><code>Lighthouse.is_early_stopping_exception</code></a></li></ul><p>The <code>AbstractClassifier</code> interface is built upon the expectation that any multiclass label will be represented in one of two standardized forms:</p><ul><li>&quot;soft label&quot;: a probability distribution vector where the <code>i</code>th element is the probability assigned to the <code>i</code>th class in <code>classes(classifier)</code>.</li><li>&quot;hard label&quot;: the interger index of a corresponding class in <code>classes(classifier)</code>.</li></ul><p>Internally, Lighthouse converts hard labels to soft labels via <code>onehot</code> and soft labels to hard labels via <code>onecold</code>.</p><p>See also: <a href="#Lighthouse.learn!"><code>learn!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/classifier.jl#L7-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.classes" href="#Lighthouse.classes"><code>Lighthouse.classes</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.classes(classifier::AbstractClassifier)</code></pre><p>Return a <code>Vector</code> or <code>Tuple</code> of class values for <code>classifier</code>.</p><p>This method must be implemented for each <code>AbstractClassifier</code> subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/classifier.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.train!" href="#Lighthouse.train!"><code>Lighthouse.train!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.train!(classifier::AbstractClassifier, batches, logger)</code></pre><p>Train <code>classifier</code> on the iterable <code>batches</code> for a single epoch. This function is called once per epoch by <a href="#Lighthouse.learn!"><code>learn!</code></a>.</p><p>This method must be implemented for each <code>AbstractClassifier</code> subtype. Implementers should ensure that the training loss is properly logged to <code>logger</code> by calling <code>Lighthouse.log_value!(logger, &quot;train/loss_per_batch&quot;, batch_loss)</code> for each batch in <code>batches</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/classifier.jl#L45-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.loss_and_prediction" href="#Lighthouse.loss_and_prediction"><code>Lighthouse.loss_and_prediction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.loss_and_prediction(classifier::AbstractClassifier,
                               input_batch::AbstractArray,
                               args...)</code></pre><p>Return <code>(loss, soft_label_batch)</code> given <code>input_batch</code> and any additional <code>args</code> provided by the caller; <code>loss</code> is a scalar, which <code>soft_label_batch</code> is a matrix with <code>length(classes(classifier))</code> rows and <code>size(input_batch)</code>.</p><p>Specifically, the <code>i</code>th column of <code>soft_label_batch</code> is <code>classifier</code>&#39;s soft label prediction for the <code>i</code>th sample in <code>input_batch</code>.</p><p>This method must be implemented for each <code>AbstractClassifier</code> subtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/classifier.jl#L58-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.onehot" href="#Lighthouse.onehot"><code>Lighthouse.onehot</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.onehot(classifier::AbstractClassifier, hard_label)</code></pre><p>Return the one-hot encoded probability distribution vector corresponding to the given <code>hard_label</code>. <code>hard_label</code> must be an integer index in the range <code>1:length(classes(classifier))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/classifier.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.onecold" href="#Lighthouse.onecold"><code>Lighthouse.onecold</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.onecold(classifier::AbstractClassifier, soft_label)</code></pre><p>Return the hard label (integer index in the range <code>1:length(classes(classifier))</code>) corresponding to the given <code>soft_label</code> (one-hot encoded probability distribution vector).</p><p>By default, this function returns <code>argmax(soft_label)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/classifier.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.is_early_stopping_exception" href="#Lighthouse.is_early_stopping_exception"><code>Lighthouse.is_early_stopping_exception</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Lighthouse.is_early_stopping_exception(classifier::AbstractClassifier, exception)</code></pre><p>Return <code>true</code> if <code>exception</code> should be considered an &quot;early-stopping exception&quot; (e.g. <code>Flux.Optimise.StopException</code>), rather than rethrown from <a href="#Lighthouse.learn!"><code>learn!</code></a>.</p><p>This function returns <code>false</code> by default, but can be overloaded by subtypes of <code>AbstractClassifier</code> that employ exceptions as early-stopping mechanisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/classifier.jl#L97-L105">source</a></section></article><h2 id="The-learn!-Interface"><a class="docs-heading-anchor" href="#The-learn!-Interface">The <code>learn!</code> Interface</a><a id="The-learn!-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-learn!-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.learn!" href="#Lighthouse.learn!"><code>Lighthouse.learn!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">learn!(model::AbstractClassifier, logger,
       get_train_batches, get_test_batches, votes,
       elected=majority.(eachrow(votes), (1:length(classes(model)),));
       epoch_limit=100, post_epoch_callback=(_ -&gt; nothing),
       optimal_threshold_class::Union{Nothing,Integer}=nothing,
       test_set_logger_prefix=&quot;test_set&quot;)</code></pre><p>Return <code>model</code> after optimizing its parameters across multiple epochs of training and test, logging Lighthouse&#39;s standardized suite of classifier performance metrics to <code>logger</code> throughout the optimization process.</p><p>The following phases are executed at each epoch (note: in the below lists of logged values, <code>$resource</code> takes the values of the field names of <code>Lighthouse.ResourceInfo</code>):</p><ol><li><p>Train <code>model</code> by calling <code>train!(model, get_train_batches(), logger)</code>. The following quantities are logged to <code>logger</code> during this phase:</p><ul><li><code>train/loss_per_batch</code></li><li>any additional quantities logged by the relevant model/framework-specific implementation of <code>train!</code>.</li></ul></li><li><p>Compute <code>model</code>&#39;s predictions on test set provided by <code>get_test_batches()</code> (see below for details). The following quantities are logged to <code>logger</code> during this phase:</p><ul><li><code>&lt;test_set_logger_prefix&gt;_prediction/loss_per_batch</code></li><li><code>&lt;test_set_logger_prefix&gt;_prediction/mean_loss_per_epoch</code></li><li><code>&lt;test_set_logger_prefix&gt;_prediction/$resource_per_batch</code></li></ul></li><li><p>Compute a battery of metrics to evaluate <code>model</code>&#39;s performance on the test set based on the test set prediction phase. The following quantities are logged to <code>logger</code> during this phase:</p><ul><li><code>&lt;test_set_logger_prefix&gt;_evaluation/metrics_per_epoch</code></li><li><code>&lt;test_set_logger_prefix&gt;_evaluation/$resource_per_epoch</code></li></ul></li><li><p>Call <code>post_epoch_callback(current_epoch)</code>.</p></li></ol><p>Where...</p><ul><li><p><code>get_train_batches</code> is a zero-argument function that returns an iterable of training set batches. Internally, <code>learn!</code> uses this function when it calls <code>train!(model, get_train_batches(), logger)</code>.</p></li><li><p><code>get_test_batches</code> is a zero-argument function that returns an iterable of test set batches used during the current epoch&#39;s test phase. Each element of the iterable takes the form <code>(batch, votes_locations)</code>. Internally, <code>batch</code> is passed to <a href="#Lighthouse.loss_and_prediction"><code>loss_and_prediction</code></a> as <code>loss_and_prediction(model, batch...)</code>, and <code>votes_locations[i]</code> is expected to yield the row index of <code>votes</code> that corresponds to the <code>i</code>th sample in <code>batch</code>.</p></li><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose rows correspond to the samples in the test set that have been voted on. If <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>elected</code> is a vector of hard labels where the <code>i</code>th element is the hard label elected as &quot;ground truth&quot; out of <code>votes[i, :]</code>.</p></li><li><p><code>optimal_threshold_class</code> is the class index (<code>1</code> or <code>2</code>) for which to calculate an optimal threshold for converting <code>predicted_soft_labels</code> to <code>predicted_hard_labels</code>. This is only a valid parameter when <code>length(classes) == 2</code>. If <code>optimal_threshold_class</code> is present, test set evaluation will be based on predicted hard labels calculated with this threshold; if <code>optimal_threshold_class</code> is <code>nothing</code>, predicted hard labels will be calculated via <code>onecold(classifier, soft_label)</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L247-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.evaluate!" href="#Lighthouse.evaluate!"><code>Lighthouse.evaluate!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate!(predicted_hard_labels::AbstractVector,
          predicted_soft_labels::AbstractMatrix,
          elected_hard_labels::AbstractVector,
          classes, logger;
          logger_prefix, logger_suffix,
          votes::Union{Nothing,AbstractMatrix}=nothing,
          thresholds=0.0:0.01:1.0,
          optimal_threshold_class::Union{Nothing,Integer}=nothing)</code></pre><p>Return <code>nothing</code> after computing and logging a battery of classifier performance metrics that each compare <code>predicted_soft_labels</code> and/or <code>predicted_hard_labels</code> agaist <code>elected_hard_labels</code>.</p><p>The following quantities are logged to <code>logger</code>:     - <code>&lt;logger_prefix&gt;/metrics&lt;logger_suffix&gt;</code>     - <code>&lt;logger_prefix&gt;/$resource&lt;logger_suffix&gt;</code></p><p>Where...</p><ul><li><p><code>predicted_soft_labels</code> is a matrix of soft labels whose columns correspond to classes and whose rows correspond to samples in the evaluation set.</p></li><li><p><code>predicted_hard_labels</code> is a vector of hard labels where the <code>i</code>th element is the hard label predicted by the model for sample <code>i</code> in the evaulation set.</p></li><li><p><code>elected_hard_labels</code> is a vector of hard labels where the <code>i</code>th element is the hard label elected as &quot;ground truth&quot; for sample <code>i</code> in the evaulation set.</p></li><li><p><code>thresholds</code> are the range of thresholds used by metrics (e.g. PR curves) that are calculated on the <code>predicted_soft_labels</code> for a range of thresholds.</p></li><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose rows correspond to the samples in the test set that have been voted on. If <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>optimal_threshold_class</code> is the class index (<code>1</code> or <code>2</code>) for which to calculate an optimal threshold for converting the <code>predicted_soft_labels</code> to <code>predicted_hard_labels</code>. If present, the input <code>predicted_hard_labels</code> will be ignored and new <code>predicted_hard_labels</code> will be recalculated from the new threshold. This is only a valid parameter when <code>length(classes) == 2</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L180-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.predict!" href="#Lighthouse.predict!"><code>Lighthouse.predict!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predict!(model::AbstractClassifier,
         predicted_soft_labels::AbstractMatrix,
         batches, logger::LearnLogger;
         logger_prefix::AbstractString)</code></pre><p>Return <code>mean_loss</code> of all <code>batches</code> after using <code>model</code> to predict their soft labels and storing those results in <code>predicted_soft_labels</code>.</p><p>The following quantities are logged to <code>logger</code>:</p><ul><li><code>&lt;logger_prefix&gt;/loss_per_batch</code></li><li><code>&lt;logger_prefix&gt;/mean_loss_per_epoch</code></li><li><code>&lt;logger_prefix&gt;/$resource_per_batch</code></li></ul><p>Where...</p><ul><li><p><code>model</code> is a model that outputs soft labels when called on a batch of <code>batches</code>, <code>model(batch)</code>.</p></li><li><p><code>predicted_soft_labels</code> is a matrix whose columns correspond to classes and whose rows correspond to samples in batches, and which is filled in with soft-label predictions.</p></li><li><p><code>batches</code> is an iterable of batches, where each element of the iterable takes the form <code>(batch, votes_locations)</code>. Internally, <code>batch</code> is passed to <a href="#Lighthouse.loss_and_prediction"><code>loss_and_prediction</code></a> as <code>loss_and_prediction(model, batch...)</code>.</p></li></ul><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L129-L156">source</a></section></article><h2 id="The-logging-interface"><a class="docs-heading-anchor" href="#The-logging-interface">The logging interface</a><a id="The-logging-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-logging-interface" title="Permalink"></a></h2><p>The following &quot;primitives&quot; must be defined for a logger to be used with Lighthouse:</p><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_value!" href="#Lighthouse.log_value!"><code>Lighthouse.log_value!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_value!(logger, field::AbstractString, value)</code></pre><p>Log a value <code>value</code> to <code>field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_line_series!" href="#Lighthouse.log_line_series!"><code>Lighthouse.log_line_series!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_line_series!(logger, field::AbstractString, curves, labels=1:length(curves))</code></pre><p>Logs a series plot to <code>logger</code> under <code>field</code>, where...</p><ul><li><code>curves</code> is an iterable of the form <code>Tuple{Vector{Real},Vector{Real}}</code>, where each tuple contains <code>(x-values, y-values)</code>, as in the <code>Lighthouse.EvaluationV1</code> field <code>per_class_roc_curves</code></li><li><code>labels</code> is the class label for each curve, which defaults to the numeric index of each curve.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_plot!" href="#Lighthouse.log_plot!"><code>Lighthouse.log_plot!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_plot!(logger, field::AbstractString, plot, plot_data)</code></pre><p>Log a <code>plot</code> to <code>logger</code> under field <code>field</code>.</p><ul><li><code>plot</code>: the plot itself</li><li><code>plot_data</code>: an unstructured dictionary of values used in creating <code>plot</code>.</li></ul><p>See also <a href="#Lighthouse.log_line_series!"><code>log_line_series!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.step_logger!" href="#Lighthouse.step_logger!"><code>Lighthouse.step_logger!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step_logger!(logger)</code></pre><p>Increments the <code>logger</code>&#39;s <code>step</code>, if any. Defaults to doing nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L38-L42">source</a></section></article><p>in addition to <code>Base.flush(logger)</code> (which can be a no-op by defining <code>Base.flush(::MyLoggingType) = nothing</code>).</p><p>These primitives can be used in implementations of <a href="#Lighthouse.train!"><code>train!</code></a>, <a href="#Lighthouse.evaluate!"><code>evaluate!</code></a>, and <a href="#Lighthouse.predict!"><code>predict!</code></a>, as well as in the following composite logging functions, which by default call the above primitives. Loggers may provide custom implementations of these.</p><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_event!" href="#Lighthouse.log_event!"><code>Lighthouse.log_event!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_event!(logger, value::AbstractString)</code></pre><p>Logs a string event given by <code>value</code> to <code>logger</code>. Defaults to calling <code>log_value!</code> with a field named <code>event</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_evaluation_row!" href="#Lighthouse.log_evaluation_row!"><code>Lighthouse.log_evaluation_row!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_evaluation_row!(logger, field::AbstractString, metrics)</code></pre><p>From fields in <a href="#Lighthouse.EvaluationV1"><code>EvaluationV1</code></a>, generate and plot the composite <a href="plotting/#Lighthouse.evaluation_metrics_plot"><code>evaluation_metrics_plot</code></a> as well as <code>spearman_correlation</code> (if present).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_values!" href="#Lighthouse.log_values!"><code>Lighthouse.log_values!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_values!(logger, values)</code></pre><p>Logs an iterable of <code>(field, value)</code> pairs to <code>logger</code>. Falls back to calling <code>log_value!</code> in a loop. Loggers may specialize this method for improved performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_array!" href="#Lighthouse.log_array!"><code>Lighthouse.log_array!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_array!(logger::Any, field::AbstractString, value)</code></pre><p>Log an array <code>value</code> to <code>field</code>.</p><p>Defaults to <code>log_value!(logger, mean(value))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.log_arrays!" href="#Lighthouse.log_arrays!"><code>Lighthouse.log_arrays!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_arrays!(logger, values)</code></pre><p>Logs an iterable of <code>(field, array)</code> pairs to <code>logger</code>. Falls back to calling <code>log_array!</code> in a loop.</p><p>Loggers may specialize this method for improved performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L78-L84">source</a></section></article><h3 id="LearnLoggers"><a class="docs-heading-anchor" href="#LearnLoggers"><code>LearnLogger</code>s</a><a id="LearnLoggers-1"></a><a class="docs-heading-anchor-permalink" href="#LearnLoggers" title="Permalink"></a></h3><p><code>LearnLoggers</code> are a Tensorboard-backed logger which comply with the above logging interface. They also support additional callback functionality with <code>upon</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.LearnLogger" href="#Lighthouse.LearnLogger"><code>Lighthouse.LearnLogger</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LearnLogger</code></pre><p>A struct that wraps a <code>TensorBoardLogger.TBLogger</code> in order to enforce the following:</p><ul><li>all values logged to Tensorboard should be accessible to the <code>post_epoch_callback</code> argument to <a href="#Lighthouse.learn!"><code>learn!</code></a></li><li>all values that are cached during <a href="#Lighthouse.learn!"><code>learn!</code></a> should be logged to Tensorboard</li></ul><p>To access values logged to a <code>LearnLogger</code> instance, inspect the instance&#39;s <code>logged</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/LearnLogger.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.upon" href="#Lighthouse.upon"><code>Lighthouse.upon</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">upon(logger::LearnLogger, field::AbstractString; condition, initial)
upon(logged::Dict{String,Any}, field::AbstractString; condition, initial)</code></pre><p>Return a closure that can be called to check the most recent state of <code>logger.logged[field]</code> and trigger a caller-provided function when <code>condition(recent_state, previously_chosen_state)</code> is <code>true</code>.</p><p>For example:</p><pre><code class="language-none">upon_loss_decrease = upon(logger, &quot;test_set_prediction/mean_loss_per_epoch&quot;;
                          condition=&lt;, initial=Inf)

save_upon_loss_decrease = _ -&gt; begin
    upon_loss_decrease(new_lowest_loss -&gt; save_my_model(model, new_lowest_loss),
                       consecutive_failures -&gt; consecutive_failures &gt; 10 &amp;&amp; Flux.stop())
end

learn!(model, logger, get_train_batches, get_test_batches, votes;
       post_epoch_callback=save_upon_loss_decrease)</code></pre><p>Specifically, the form of the returned closure is <code>f(on_true, on_false)</code> where <code>on_true(state)</code> is called if <code>condition(state, previously_chosen_state)</code> is <code>true</code>. Otherwise, <code>on_false(consecutive_falses)</code> is called where <code>consecutive_falses</code> is the number of <code>condition</code> calls that have returned <code>false</code> since the last <code>condition</code> call returned <code>true</code>.</p><p>Note that the returned closure is a no-op if <code>logger.logged[field]</code> has not been updated since the most recent call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/learn.jl#L361-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.forward_logs" href="#Lighthouse.forward_logs"><code>Lighthouse.forward_logs</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">forwarding_task = forward_logs(channel, logger::LearnLogger)</code></pre><p>Forwards logs with values supported by <code>TensorBoardLogger</code> to <code>logger::LearnLogger</code>:</p><ul><li>string events of type <code>AbstractString</code></li><li>scalars of type <code>Union{Real,Complex}</code></li><li>plots that <code>TensorBoardLogger</code> can convert to raster images</li></ul><p>returns the <code>forwarding_task:::Task</code> that does the forwarding. To cleanly stop forwarding, <code>close(channel)</code> and <code>wait(forwarding_task)</code>.</p><p>outbox is a Channel or RemoteChannel of Pair{String, Any} field names starting with &quot;<strong>plot</strong>&quot; forward to TensorBoardLogger.log_image</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/LearnLogger.jl#L61-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.flush-Tuple{LearnLogger}" href="#Base.flush-Tuple{LearnLogger}"><code>Base.flush</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.flush(logger::LearnLogger)</code></pre><p>Persist possibly transient logger state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/LearnLogger.jl#L54-L58">source</a></section></article><h2 id="Performance-Metrics"><a class="docs-heading-anchor" href="#Performance-Metrics">Performance Metrics</a><a id="Performance-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Metrics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.confusion_matrix" href="#Lighthouse.confusion_matrix"><code>Lighthouse.confusion_matrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">confusion_matrix(class_count::Integer, hard_label_pairs = ())</code></pre><p>Given the iterable <code>hard_label_pairs</code> whose <code>k</code>th element takes the form <code>(first_classifiers_label_for_sample_k, second_classifiers_label_for_sample_k)</code>, return the corresponding confusion matrix where <code>matrix[i, j]</code> is the number of samples that the first classifier labeled <code>i</code> and the second classifier labeled <code>j</code>.</p><p>Note that the returned confusion matrix can be updated in-place with new labels via <code>Lighthouse.increment_at!(matrix, more_hard_label_pairs)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.accuracy" href="#Lighthouse.accuracy"><code>Lighthouse.accuracy</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accuracy(confusion::AbstractMatrix)</code></pre><p>Returns the percentage of matching classifications out of total classifications, or <code>NaN</code> if <code>all(iszero, confusion)</code>.</p><p>Note that <code>accuracy(confusion)</code> is equivalent to overall percent agreement between <code>confusion</code>&#39;s row classifier and column classifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.binary_statistics" href="#Lighthouse.binary_statistics"><code>Lighthouse.binary_statistics</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">binary_statistics(confusion::AbstractMatrix, class_index)</code></pre><p>Treating the rows of <code>confusion</code> as corresponding to predicted classifications and the columns as corresponding to true classifications, return a <code>NamedTuple</code> with the following fields for the given <code>class_index</code>:</p><ul><li><code>predicted_positives</code></li><li><code>predicted_negatives</code></li><li><code>actual_positives</code></li><li><code>actual_negatives</code></li><li><code>true_positives</code></li><li><code>true_negatives</code></li><li><code>false_positives</code></li><li><code>false_negatives</code></li><li><code>true_positive_rate</code></li><li><code>true_negative_rate</code></li><li><code>false_positive_rate</code></li><li><code>false_negative_rate</code></li><li><code>precision</code></li><li><code>f1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L44-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.cohens_kappa" href="#Lighthouse.cohens_kappa"><code>Lighthouse.cohens_kappa</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cohens_kappa(class_count, hard_label_pairs)</code></pre><p>Return <code>(Œ∫, p‚ÇÄ)</code> where <code>Œ∫</code> is Cohen&#39;s kappa and <code>p‚ÇÄ</code> percent agreement given <code>class_count</code> and <code>hard_label_pairs</code> (these arguments take the same form as their equivalents in <a href="#Lighthouse.confusion_matrix"><code>confusion_matrix</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.calibration_curve" href="#Lighthouse.calibration_curve"><code>Lighthouse.calibration_curve</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calibration_curve(probabilities, bitmask; bin_count=10)</code></pre><p>Given <code>probabilities</code> (the predicted probabilities of the positive class) and <code>bitmask</code> (a vector of <code>Bool</code>s indicating whether or not the element actually belonged to the positive class), return <code>(bins, fractions, totals, mean_squared_error)</code> where:</p><ul><li><code>bins</code> a vector with <code>bin_count</code> <code>Pairs</code> specifying the calibration curve&#39;s probability bins</li><li><code>fractions</code>: a vector where <code>fractions[i]</code> is the number of values in <code>probabilities</code> that falls within <code>bin[i]</code> over the total number of values within <code>bin[i]</code>, or <code>NaN</code> if the total number of values in <code>bin[i]</code> is zero.</li><li><code>totals</code>: a vector where <code>totals[i]</code> the total number of values within <code>bin[i]</code>.</li><li><code>mean_squared_error</code>: The mean squared error of <code>fractions</code> vs. an ideal calibration curve.</li></ul><p>This method is similar to the corresponding scikit-learn method:</p><p>https://scikit-learn.org/stable/modules/generated/sklearn.calibration.calibration_curve.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L127-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.EvaluationV1" href="#Lighthouse.EvaluationV1"><code>Lighthouse.EvaluationV1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version EvaluationV1 begin
    class_labels::Union{Missing,Vector{String}}
    confusion_matrix::Union{Missing,Array{Int64,1},Array{Int64,2}} = vec_to_mat(confusion_matrix)
    discrimination_calibration_curve::Union{Missing,GenericCurve}
    discrimination_calibration_score::Union{Missing,Float64}
    multiclass_IRA_kappas::Union{Missing,Float64}
    multiclass_kappa::Union{Missing,Float64}
    optimal_threshold::Union{Missing,Float64}
    optimal_threshold_class::Union{Missing,Int64}
    per_class_IRA_kappas::Union{Missing,Vector{Float64}}
    per_class_kappas::Union{Missing,Vector{Float64}}
    stratified_kappas::Union{Missing,
                             Vector{@NamedTuple{per_class::Vector{Float64},
                                                multiclass::Float64,
                                                n::Int64}}}
    per_class_pr_curves::Union{Missing,Vector{GenericCurve}}
    per_class_reliability_calibration_curves::Union{Missing,Vector{GenericCurve}}
    per_class_reliability_calibration_scores::Union{Missing,Vector{Float64}}
    per_class_roc_aucs::Union{Missing,Vector{Float64}}
    per_class_roc_curves::Union{Missing,Vector{GenericCurve}}
    per_expert_discrimination_calibration_curves::Union{Missing,Vector{GenericCurve}}
    per_expert_discrimination_calibration_scores::Union{Missing,Vector{Float64}}
    spearman_correlation::Union{Missing,
                                @NamedTuple{œÅ::Float64,  # Note: is rho not &#39;p&#39; üò¢
                                            n::Int64,
                                            ci_lower::Float64,
                                            ci_upper::Float64}}
    thresholds::Union{Missing,Vector{Float64}}
end</code></pre><p>A Legolas record representing the output metrics computed by <a href="#Lighthouse.evaluation_metrics_record"><code>evaluation_metrics_record</code></a> and <a href="#Lighthouse.evaluation_metrics"><code>evaluation_metrics</code></a>.</p><p>See <a href="https://github.com/beacon-biosignals/Legolas.jl">Legolas.jl</a> for details regarding Legolas record types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L53-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.ObservationV1" href="#Lighthouse.ObservationV1"><code>Lighthouse.ObservationV1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version ObservationV1 begin
    predicted_hard_label::Int64
    predicted_soft_labels::Vector{Float32}
    elected_hard_label::Int64
    votes::Union{Missing,Vector{Int64}}
end</code></pre><p>A Legolas record representing the per-observation input values required to compute <a href="#Lighthouse.evaluation_metrics_record"><code>evaluation_metrics_record</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L125-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.evaluation_metrics" href="#Lighthouse.evaluation_metrics"><code>Lighthouse.evaluation_metrics</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluation_metrics(args...; optimal_threshold_class=nothing, kwargs...)</code></pre><p>Return <a href="#Lighthouse.evaluation_metrics_record"><code>evaluation_metrics_record</code></a> after converting output <code>EvaluationV1</code> into a <code>Dict</code>. For argument details, see <a href="#Lighthouse.evaluation_metrics_record"><code>evaluation_metrics_record</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L331-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._evaluation_dict" href="#Lighthouse._evaluation_dict"><code>Lighthouse._evaluation_dict</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_evaluation_row_dict(row::EvaluationV1) -&gt; Dict{String,Any}</code></pre><p>Convert <a href="#Lighthouse.EvaluationV1"><code>EvaluationV1</code></a> into <code>::Dict{String, Any}</code> results, as are output by <code>[</code>evaluation_metrics<code>](@ref)</code> (and predated use of <code>EvaluationV1</code> in Lighthouse &lt;v0.14.0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.evaluation_metrics_record" href="#Lighthouse.evaluation_metrics_record"><code>Lighthouse.evaluation_metrics_record</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluation_metrics_record(observation_table, classes, thresholds=0.0:0.01:1.0;
                          strata::Union{Nothing,AbstractVector{Set{T}} where T}=nothing,
                          optimal_threshold_class::Union{Missing,Nothing,Integer}=missing)
evaluation_metrics_record(predicted_hard_labels::AbstractVector,
                          predicted_soft_labels::AbstractMatrix,
                          elected_hard_labels::AbstractVector,
                          classes,
                          thresholds=0.0:0.01:1.0;
                          votes::Union{Nothing,Missing,AbstractMatrix}=nothing,
                          strata::Union{Nothing,AbstractVector{Set{T}} where T}=nothing,
                          optimal_threshold_class::Union{Missing,Nothing,Integer}=missing)</code></pre><p>Returns <code>EvaluationV1</code> containing a battery of classifier performance metrics that each compare <code>predicted_soft_labels</code> and/or <code>predicted_hard_labels</code> agaist <code>elected_hard_labels</code>.</p><p>Where...</p><ul><li><p><code>predicted_soft_labels</code> is a matrix of soft labels whose columns correspond to classes and whose rows correspond to samples in the evaluation set.</p></li><li><p><code>predicted_hard_labels</code> is a vector of hard labels where the <code>i</code>th element is the hard label predicted by the model for sample <code>i</code> in the evaulation set.</p></li><li><p><code>elected_hard_labels</code> is a vector of hard labels where the <code>i</code>th element is the hard label elected as &quot;ground truth&quot; for sample <code>i</code> in the evaulation set.</p></li><li><p><code>thresholds</code> are the range of thresholds used by metrics (e.g. PR curves) that are calculated on the <code>predicted_soft_labels</code> for a range of thresholds.</p></li><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose rows correspond to the samples in the test set that have been voted on. If <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>strata</code> is a vector of sets of (arbitrarily typed) groups/strata for each sample in the evaluation set, or <code>nothing</code>. If not <code>nothing</code>, per-class and multiclass kappas will also be calculated per group/stratum.</p></li><li><p><code>optimal_threshold_class</code> is the class index (<code>1</code> or <code>2</code>) for which to calculate an optimal threshold for converting the <code>predicted_soft_labels</code> to <code>predicted_hard_labels</code>. If present, the input <code>predicted_hard_labels</code> will be ignored and new <code>predicted_hard_labels</code> will be recalculated from the new threshold. This is only a valid parameter when <code>length(classes) == 2</code></p></li></ul><p>Alternatively, an <code>observation_table</code> that consists of rows of type <a href="#Lighthouse.ObservationV1"><code>ObservationV1</code></a> can be passed in in place of <code>predicted_soft_labels</code>,<code>predicted_hard_labels</code>,<code>elected_hard_labels</code>, and <code>votes</code>. Supply a function to the keyword argument <code>binarize</code> which takes as input <code>(soft_label, threshold)</code> and outputs a <code>Bool</code> indicating whether or not the class of interest.</p><p>See also <a href="plotting/#Lighthouse.evaluation_metrics_plot"><code>evaluation_metrics_plot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L344-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.ClassV1" href="#Lighthouse.ClassV1"><code>Lighthouse.ClassV1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version ClassV1 begin
    class_index::Union{Int64,Symbol} = check_valid_class(class_index)
    class_labels::Union{Missing,Vector{String}}
end</code></pre><p>A Legolas record representing a single column <code>class_index</code> that holds either an integer or the value <code>:multiclass</code>, and the class names associated to the integer class indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L236-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.TradeoffMetricsV1" href="#Lighthouse.TradeoffMetricsV1"><code>Lighthouse.TradeoffMetricsV1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version TradeoffMetricsV1 &gt; ClassV1 begin
    roc_curve::Curve = lift(Curve, roc_curve)
    roc_auc::Float64
    pr_curve::Curve = lift(Curve, pr_curve)
    spearman_correlation::Union{Missing,Float64}
    spearman_correlation_ci_upper::Union{Missing,Float64}
    spearman_correlation_ci_lower::Union{Missing,Float64}
    n_samples::Union{Missing,Int}
    reliability_calibration_curve::Union{Missing,Curve} = lift(Curve,
                                                               reliability_calibration_curve)
    reliability_calibration_score::Union{Missing,Float64}
end</code></pre><p>A Legolas record representing metrics calculated over predicted soft labels. See also <a href="#Lighthouse.get_tradeoff_metrics"><code>get_tradeoff_metrics</code></a> and <a href="#Lighthouse.get_tradeoff_metrics_binary_multirater"><code>get_tradeoff_metrics_binary_multirater</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L313-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.get_tradeoff_metrics" href="#Lighthouse.get_tradeoff_metrics"><code>Lighthouse.get_tradeoff_metrics</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_tradeoff_metrics(predicted_soft_labels, elected_hard_labels, class_index;
                     thresholds, binarize=binarize_by_threshold, class_labels=missing)</code></pre><p>Return [<code>TradeoffMetricsV1</code>] calculated for the given <code>class_index</code>, with the following fields guaranteed to be non-missing: <code>roc_curve</code>, <code>roc_auc</code>, pr<em>curve<code>,</code>reliability</em>calibration<em>curve<code>,</code>reliability</em>calibration<em>score<code>.</code> Supply a function to the keyword argument <code>binarize</code> which takes as input `(soft</em>label, threshold)<code>and outputs a</code>Bool<code>indicating whether or not the class of interest (</code>class_index`).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L188-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.get_tradeoff_metrics_binary_multirater" href="#Lighthouse.get_tradeoff_metrics_binary_multirater"><code>Lighthouse.get_tradeoff_metrics_binary_multirater</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_tradeoff_metrics_binary_multirater(predicted_soft_labels, elected_hard_labels, class_index;
                                       thresholds, binarize=binarize_by_threshold, class_labels=missing)</code></pre><p>Return [<code>TradeoffMetricsV1</code>] calculated for the given <code>class_index</code>. In addition to metrics calculated by <a href="#Lighthouse.get_tradeoff_metrics"><code>get_tradeoff_metrics</code></a>, additionally calculates <code>spearman_correlation</code>-based metrics. Supply a function to the keyword argument <code>binarize</code> which takes as input <code>(soft_label, threshold)</code> and outputs a <code>Bool</code> indicating whether or not the class of interest (<code>class_index</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.HardenedMetricsV1" href="#Lighthouse.HardenedMetricsV1"><code>Lighthouse.HardenedMetricsV1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version HardenedMetricsV1 &gt; ClassV1 begin
    confusion_matrix::Union{Missing,Array{Int64,1},Array{Int64,2}} = vec_to_mat(confusion_matrix)
    discrimination_calibration_curve::Union{Missing,Curve} = lift(Curve,
                                                                  discrimination_calibration_curve)
    discrimination_calibration_score::Union{Missing,Float64}
    ea_kappa::Union{Missing,Float64}
end</code></pre><p>A Legolas record representing metrics calculated over predicted hard labels. See also <a href="#Lighthouse.get_hardened_metrics"><code>get_hardened_metrics</code></a>, <a href="#Lighthouse.get_hardened_metrics_multirater"><code>get_hardened_metrics_multirater</code></a>, and <a href="#Lighthouse.get_hardened_metrics_multiclass"><code>get_hardened_metrics_multiclass</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L284-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.get_hardened_metrics" href="#Lighthouse.get_hardened_metrics"><code>Lighthouse.get_hardened_metrics</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_hardened_metrics(predicted_hard_labels, elected_hard_labels, class_index;
                     class_labels=missing)</code></pre><p>Return [<code>HardenedMetricsV1</code>] calculated for the given <code>class_index</code>, with the following field guaranteed to be non-missing: expert-algorithm agreement (<code>ea_kappa</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L240-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.get_hardened_metrics_multirater" href="#Lighthouse.get_hardened_metrics_multirater"><code>Lighthouse.get_hardened_metrics_multirater</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_hardened_metrics_multirater(predicted_hard_labels, elected_hard_labels, class_index;
                     class_labels=missing)</code></pre><p>Return [<code>HardenedMetricsV1</code>] calculated for the given <code>class_index</code>. In addition to metrics calculated by <a href="#Lighthouse.get_hardened_metrics"><code>get_hardened_metrics</code></a>, additionally calculates <code>discrimination_calibration_curve</code> and <code>discrimination_calibration_score</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.get_hardened_metrics_multiclass" href="#Lighthouse.get_hardened_metrics_multiclass"><code>Lighthouse.get_hardened_metrics_multiclass</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_hardened_metrics_multiclass(predicted_hard_labels, elected_hard_labels,
                                class_count; class_labels=missing)</code></pre><p>Return [<code>HardenedMetricsV1</code>] calculated over all <code>class_count</code> classes. Calculates expert-algorithm agreement (<code>ea_kappa</code>) over all classes, as well as the multiclass <code>confusion_matrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L275-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.LabelMetricsV1" href="#Lighthouse.LabelMetricsV1"><code>Lighthouse.LabelMetricsV1</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@version LabelMetricsV1 &gt; ClassV1 begin
    ira_kappa::Union{Missing,Float64}
    per_expert_discrimination_calibration_curves::Union{Missing,Vector{Curve}} = lift(v -&gt; Curve.(v),
                                                                                      per_expert_discrimination_calibration_curves)
    per_expert_discrimination_calibration_scores::Union{Missing,Vector{Float64}}
end</code></pre><p>A Legolas record representing metrics calculated over labels provided by multiple labelers. See also <a href="#Lighthouse.get_label_metrics_multirater"><code>get_label_metrics_multirater</code></a> and  <a href="#Lighthouse.get_label_metrics_multirater_multiclass"><code>get_label_metrics_multirater_multiclass</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L262-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.get_label_metrics_multirater" href="#Lighthouse.get_label_metrics_multirater"><code>Lighthouse.get_label_metrics_multirater</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_label_metrics_multirater(votes, class_index; class_labels=missing)</code></pre><p>Return [<code>LabelMetricsV1</code>] calculated for the given <code>class_index</code>, with the following field guaranteed to be non-missing: <code>per_expert_discrimination_calibration_curves</code>, <code>per_expert_discrimination_calibration_scores</code>, interrater-agreement (<code>ira_kappa</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L294-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.get_label_metrics_multirater_multiclass" href="#Lighthouse.get_label_metrics_multirater_multiclass"><code>Lighthouse.get_label_metrics_multirater_multiclass</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_label_metrics_multirater_multiclass(votes, class_count; class_labels=missing)</code></pre><p>Return [<code>LabelMetricsV1</code>] calculated over all <code>class_count</code> classes. Calculates the multiclass interrater agreement (<code>ira_kappa</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L314-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._evaluation_record" href="#Lighthouse._evaluation_record"><code>Lighthouse._evaluation_record</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_evaluation_record(tradeoff_metrics_table, hardened_metrics_table, label_metrics_table;
                   optimal_threshold_class=missing, class_labels, thresholds,
                   optimal_threshold, stratified_kappas=missing)</code></pre><p>Helper function to create an <code>EvaluationV1</code> from tables of constituent Metrics schemas, to support <a href="#Lighthouse.evaluation_metrics_record"><code>evaluation_metrics_record</code></a>:</p><ul><li><code>tradeoff_metrics_table</code>: table of <a href="#Lighthouse.TradeoffMetricsV1"><code>TradeoffMetricsV1</code></a>s</li><li><code>hardened_metrics_table</code>: table of <a href="#Lighthouse.HardenedMetricsV1"><code>HardenedMetricsV1</code></a>s</li><li><code>label_metrics_table</code>: table of <a href="#Lighthouse.LabelMetricsV1"><code>LabelMetricsV1</code></a>s</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L530-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._calculate_ea_kappas" href="#Lighthouse._calculate_ea_kappas"><code>Lighthouse._calculate_ea_kappas</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_calculate_ea_kappas(predicted_hard_labels, elected_hard_labels, classes)</code></pre><p>Return <code>NamedTuple</code> with keys <code>:per_class_kappas</code>, <code>:multiclass_kappa</code> containing the Cohen&#39;s Kappa per-class and over all classes, respectively. The value of output key <code>:per_class_kappas</code> is an <code>Array</code> such that item <code>i</code> is the Cohen&#39;s kappa calculated for class <code>i</code>.</p><p>Where...</p><ul><li><p><code>predicted_hard_labels</code> is a vector of hard labels where the <code>i</code>th element is the hard label predicted by the model for sample <code>i</code> in the evaulation set.</p></li><li><p><code>elected_hard_labels</code> is a vector of hard labels where the <code>i</code>th element is the hard label elected as &quot;ground truth&quot; for sample <code>i</code> in the evaulation set.</p></li><li><p><code>class_count</code> is the number of possible classes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L633-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._calculate_ira_kappas" href="#Lighthouse._calculate_ira_kappas"><code>Lighthouse._calculate_ira_kappas</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_calculate_ira_kappas(votes, classes)</code></pre><p>Return <code>NamedTuple</code> with keys <code>:per_class_IRA_kappas</code>, <code>:multiclass_IRA_kappas</code> containing the Cohen&#39;s Kappa for inter-rater agreement (IRA) per-class and over all classes, respectively. The value of output key <code>:per_class_IRA_kappas</code> is an <code>Array</code> such that item <code>i</code> is the IRA kappa calculated for class <code>i</code>.</p><p>Where...</p><ul><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose rows correspond to the samples in the test set that have been voted on. If <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will simply be considered to have not assigned a hard label to <code>sample</code>.</p></li><li><p><code>classes</code> all possible classes voted on.</p></li></ul><p>Returns <code>(per_class_IRA_kappas=missing, multiclass_IRA_kappas=missing)</code> if <code>votes</code> has only a single voter (i.e., a single column) or if no two voters rated the same sample. Note that vote entries of <code>0</code> are taken to mean that the voter did not rate that sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L669-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse._calculate_spearman_correlation" href="#Lighthouse._calculate_spearman_correlation"><code>Lighthouse._calculate_spearman_correlation</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_calculate_spearman_correlation(predicted_soft_labels, votes, classes)</code></pre><p>Return <code>NamedTuple</code> with keys <code>:œÅ</code>, <code>:n</code>, <code>:ci_lower</code>, and <code>ci_upper</code> that are the Spearman correlation constant œÅ and its 95% confidence interval bounds. Only valid for binary classification problems (i.e., <code>length(classes) == 2</code>)</p><p>Where...</p><ul><li><p><code>predicted_soft_labels</code> is a matrix of soft labels whose columns correspond to the two classes and whose rows correspond to the samples in the test set that have been classified. For a given sample, the two class column values must sum to 1 (i.e., softmax has been applied to the classification output).</p></li><li><p><code>votes</code> is a matrix of hard labels whose columns correspond to voters and whose rows correspond to the samples in the test set that have been voted on. If <code>votes[sample, voter]</code> is not a valid hard label for <code>model</code>, then <code>voter</code> will simply be considered to have not assigned a hard label to <code>sample</code>. May contain a single voter (i.e., a single column).</p></li><li><p><code>classes</code> are the two classes voted on.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/metrics.jl#L759-L780">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.majority" href="#Lighthouse.majority"><code>Lighthouse.majority</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">majority([rng::AbstractRNG=Random.GLOBAL_RNG], hard_labels, among::UnitRange)</code></pre><p>Return the majority label within <code>among</code> out of <code>hard_labels</code>:</p><pre><code class="language-none">julia&gt; majority([1, 2, 1, 3, 2, 2, 3], 1:3)
2

julia&gt; majority([1, 2, 1, 3, 2, 2, 3, 4], 3:4)
3</code></pre><p>In the event of a tie, a winner is randomly selected from the tied labels via <code>rng</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/utilities.jl#L52-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.area_under_curve" href="#Lighthouse.area_under_curve"><code>Lighthouse.area_under_curve</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">area_under_curve(x, y)</code></pre><p>Calculates the area under the curve specified by the <code>x</code> vector and <code>y</code> vector using the trapezoidal rule. If inputs are empty, return <code>NaN</code>. Excludes NaN entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/utilities.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.area_under_curve_unit_square" href="#Lighthouse.area_under_curve_unit_square"><code>Lighthouse.area_under_curve_unit_square</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">area_under_curve_unit_square(x, y)</code></pre><p>Calculates the area under the curve specified by the <code>x</code> vector and <code>y</code> vector for a unit square, using the trapezoidal rule. If inputs are empty, return <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/utilities.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Lighthouse.Curve" href="#Lighthouse.Curve"><code>Lighthouse.Curve</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Curve(x, y)</code></pre><p>Represents a (plot) curve of <code>x</code> and <code>y</code> points.</p><p>When constructing a <code>Curve</code>, <code>missing</code>&#39;s are replaced with <code>NaN</code>, and values are converted to <code>Float64</code>. Curve objects <code>c</code> support iteration, <code>x, y = c</code>, and indexing, <code>x = c[1]</code>, <code>y = c[2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/Lighthouse.jl/blob/710925a3fe450f8af97218e3c4a9103b0be25e3f/src/row.jl#L189-L196">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="plotting/">Plotting ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 13 December 2024 18:24">Friday 13 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
